#lang racket
(define (return x) x)
(define (k+ a b k)
  (k (+ a b)))
(define (k* a b k)
  (k (* a b)))
(k+ 1 2 (lambda (x) (k* x 3 return)))
(define (fact n)
  (if (= n 1)
      1
      (* n (fact (- n 1)))))
(define (kfact n k)
  (if (= n 1)
      (k 1)
      (kfact (- n 1) (lambda(x) (k (* n x))))))
(+ 3 (fact 4))
(define (product ls)
  (let loop ([ls ls] [acc 1])
    (cond
      ((null? ls) acc)
      ((zero? (car ls)) 0)
      (else (loop (cdr ls) (* (car ls) acc))))))
(define (kproduct ls k)
  (let ([break k])
    (let loop ([ls ls] [k k])
      (cond 
        ((null? ls) (k 1))
        ((zero? (car ls )) (break 0))
        (else (loop (cdr ls) (lambda (x) (k (* (car ls) x)))))))))
(+ 100 (product (list 2 4 7)))
(kproduct '(2 4 7) (lambda(x) (k+ x 100 return)))
(define (non-number-value-error x)
  (display "Value error:")
  (display x)
  (display "is not number")
  (newline))
(define (kproduct1 ls k k-value-error)
  (let ([break k])
    (let loop ([ls ls] [k k])
      (cond 
        ((null? ls) (k 1))
        ((not (number? (car ls))) (k-value-error (car ls)))
        ((zero? (car ls)) (break 0))
        (else (loop (cdr ls) (lambda (x) (k (* (car ls) x)))))))))
(kproduct1 '(2 4 7 hoge)
           (lambda (x) (k+ x 100 return))
           non-number-value-error)
